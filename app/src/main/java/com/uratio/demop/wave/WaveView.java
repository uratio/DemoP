package com.uratio.demop.wave;import android.content.Context;import android.graphics.Canvas;import android.graphics.Paint;import android.support.annotation.Nullable;import android.util.AttributeSet;import android.util.Log;import android.view.View;import java.util.Arrays;import java.util.Random;/** * @author： lizhi. * @date：2021/3/30-3:50 PM * @desc: */public class WaveView extends View {    private int width;    private int height;    private int volume = 0;    private int lineWidth = 10;    private int spaceWidth = 10;    private int startX = 0;    private Paint mPaint;    private float[] waves;    private int centerOne;    private int centerTwo;    private int extendNum = 4;    private long drawTime;    private int invalidateTime = 100;    /**     * 灵敏度     */    private int sensibility = 4;    private int maxVolume = 100;    public WaveView(Context context) {        super(context);        initPaint();    }    public WaveView(Context context, @Nullable AttributeSet attrs) {        super(context, attrs);        initPaint();    }    public WaveView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {        super(context, attrs, defStyleAttr);        initPaint();    }    private void initPaint() {        mPaint = new Paint();        mPaint.setColor(0xFFFF6D26);        mPaint.setStrokeWidth(lineWidth);        mPaint.setAntiAlias(true);        mPaint.setFilterBitmap(true);        mPaint.setStrokeCap(Paint.Cap.ROUND);        mPaint.setStyle(Paint.Style.FILL);    }//    @Override//    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {//        super.onMeasure(widthMeasureSpec, heightMeasureSpec);//        width = getWidth();//        height = getHeight();//        Log.e("data", "onSizeChanged: width=" + width);//        int maxLines = width / (lineWidth + spaceWidth);//        Log.e("data", "onSizeChanged: maxLines=" + maxLines);//        maxLines = maxLines % 2 == 1 ? maxLines : maxLines - 1;//        Log.e("data", "onSizeChanged: maxLines=" + maxLines);//        centerOne = (maxLines - 1) / 4;//        centerTwo = maxLines - centerOne - 1;//        extendNum = centerOne / 2;//        if (waves == null) {//            waves = new float[maxLines];//        }//        for (int i = 0; i < waves.length; i++) {//            waves[i] = lineWidth;//        }////        // 绘画起始位置//        startX = (width + spaceWidth - maxLines * (lineWidth + spaceWidth)) / 2 + spaceWidth / 2;////        Log.e("data", "onSizeChanged: lineWidth=" + lineWidth);//        Log.e("data", "onSizeChanged: startX=" + startX);//    }    @Override    protected void onSizeChanged(int w, int h, int oldw, int oldh) {        width = w;        height = h;        Log.e("data", "onSizeChanged: width=" + width);        Log.e("data", "onSizeChanged: height=" + height);        int maxLines = w / (lineWidth + spaceWidth);        Log.e("data", "onSizeChanged: maxLines=" + maxLines);        maxLines = maxLines % 2 == 1 ? maxLines : maxLines - 1;        Log.e("data", "onSizeChanged: maxLines=" + maxLines);        centerOne = (maxLines - 1) / 4;        centerTwo = maxLines - centerOne - 1;        extendNum = centerOne / 2;        Log.e("data", "onSizeChanged: centerOne=" + centerOne);        Log.e("data", "onSizeChanged: centerTwo=" + centerTwo);        Log.e("data", "onSizeChanged: extendNum=" + extendNum);        if (waves == null) {            waves = new float[maxLines];        }        for (int i = 0; i < waves.length; i++) {            waves[i] = lineWidth;        }        // 绘画起始位置        startX = (width + spaceWidth - maxLines * (lineWidth + spaceWidth)) / 2 + spaceWidth / 2;        Log.e("data", "onSizeChanged: lineWidth=" + lineWidth);        Log.e("data", "onSizeChanged: width=" + width);        Log.e("data", "onSizeChanged: startX=" + startX);    }    @Override    public void draw(Canvas canvas) {        super.draw(canvas);        canvas.translate(startX, height / 2);        for (int i = 0; i < waves.length; i++) {            int x = i * (lineWidth + spaceWidth);//            if (i == centerOne) {//                canvas.drawLine(x, -waves[i], x, 0, mPaint);//            } else if (i == centerTwo) {//                canvas.drawLine(x, 0, x, waves[i], mPaint);//            } else {                canvas.drawLine(x, -waves[i], x, waves[i], mPaint);//            }        }    }    public void setVolume(int volume) {        int targetVolume = 0;        if (volume > maxVolume * sensibility / 25) {            targetVolume = volume * height / 2 / maxVolume;        }        int intervalH = (targetVolume - lineWidth) / extendNum;        for (int i = 0; i <= extendNum * 2 + 1; i++) {            if (i < extendNum) {                waves[centerOne - extendNum + i] = lineWidth + (i + 1) * intervalH;                waves[centerTwo - extendNum + i] = lineWidth + (i + 1) * intervalH;            } else if (i > extendNum) {                waves[centerOne - extendNum + i] = lineWidth + (extendNum * 2 - i + 1) * intervalH;                waves[centerTwo - extendNum + i] = lineWidth + (extendNum * 2 - i + 1) * intervalH;            } else {                waves[centerOne] = targetVolume;                waves[centerTwo] = targetVolume;            }        }        Log.e("data", "onSizeChanged: waves=" + Arrays.toString(waves));////        datas.clear();////        volume = volume/10;////////        if(volume == 0)////            volume = 10;////        for (int q = 0; q < 100; q++) {////////            for (int i = 0; i < marAnimNum; i++) {////                datas.add(new Random().nextInt(10));////            }////            if (volume > height/2)////                volume = (height/2-10);////            for (int j = marAnimNum; j < maxLines - marAnimNum; j++) {//                datas.add(new Random().nextInt(volume));////            }////            for (int i = 0; i < marAnimNum; i++) {////                datas.add(new Random().nextInt(10));////            }////            if (System.currentTimeMillis() - drawTime > invalidateTime) {////                invalidate();////                drawTime = System.currentTimeMillis();////            }////        }            if (System.currentTimeMillis() - drawTime > invalidateTime) {                invalidate();                drawTime = System.currentTimeMillis();            }    }}