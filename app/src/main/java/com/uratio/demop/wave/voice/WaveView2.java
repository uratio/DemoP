package com.uratio.demop.wave.voice;import android.content.Context;import android.graphics.Canvas;import android.graphics.Paint;import android.support.annotation.Nullable;import android.util.AttributeSet;import android.util.Log;import android.view.View;import java.util.concurrent.ThreadLocalRandom;public class WaveView2 extends View {    private int width;    private int height;    private int lineWidth = 5;    private int spaceWidth = 5;    private int startX = 0;    private Paint mPaint;    private float[] waves;    private int centerOne;    private int centerTwo;    private int extendNum = 4;    private long drawTime;    private int invalidateTime = 100;    /**     * 灵敏度     */    private int sensibility = 4;    private int maxVolume = 100;    public WaveView2(Context context) {        super(context);        initPaint();    }    public WaveView2(Context context, @Nullable AttributeSet attrs) {        super(context, attrs);        initPaint();    }    public WaveView2(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {        super(context, attrs, defStyleAttr);        initPaint();    }    private void initPaint() {        mPaint = new Paint();        mPaint.setColor(0xFFFF6D26);        mPaint.setStrokeWidth(lineWidth);        mPaint.setAntiAlias(true);        mPaint.setFilterBitmap(true);        mPaint.setStrokeCap(Paint.Cap.ROUND);        mPaint.setStyle(Paint.Style.FILL);    }    @Override    protected void onSizeChanged(int w, int h, int oldw, int oldh) {        width = w;        height = h;//        Log.e("data", "onSizeChanged: width=" + width);//        Log.e("data", "onSizeChanged: height=" + height);        int maxLines = w / (lineWidth + spaceWidth);//        Log.e("data", "onSizeChanged: maxLines=" + maxLines);        maxLines = maxLines % 2 == 1 ? maxLines : maxLines - 1;//        Log.e("data", "onSizeChanged: maxLines=" + maxLines);        centerOne = (maxLines - 1) / 4;        centerTwo = maxLines - centerOne - 1;        extendNum = centerOne / 2;//        Log.e("data", "onSizeChanged: centerOne=" + centerOne);//        Log.e("data", "onSizeChanged: centerTwo=" + centerTwo);//        Log.e("data", "onSizeChanged: extendNum=" + extendNum);        if (waves == null) {            waves = new float[maxLines];        }        for (int i = 0; i < waves.length; i++) {            waves[i] = lineWidth;        }        // 绘画起始位置        startX = (width + spaceWidth - maxLines * (lineWidth + spaceWidth)) / 2 + spaceWidth / 2;        Log.e("data", "onSizeChanged: lineWidth=" + lineWidth);        Log.e("data", "onSizeChanged: width=" + width);        Log.e("data", "onSizeChanged: startX=" + startX);    }    @Override    public void draw(Canvas canvas) {        super.draw(canvas);        canvas.translate(startX, height / 2);        for (int i = 0; i < waves.length; i++) {            int x = i * (lineWidth + spaceWidth);            canvas.drawLine(x, -waves[i], x, waves[i], mPaint);        }    }    public void setVolume(int volume) {        if (System.currentTimeMillis() - drawTime < invalidateTime) return;        if (volume >= 3000) {            volume = 100;        } else {            volume = (int) (volume / 30f);        }        if (volume > 50) {            volume = (height / 2 - 10);        }        ThreadLocalRandom.current().nextInt(0, volume);//        volume / maxVolume        float targetVolume = 0;        if (volume > maxVolume * sensibility / 25) {            targetVolume = 1.0f * volume * height / 2 / maxVolume;        }        float intervalH = (targetVolume - lineWidth) / extendNum;        for (int i = 0; i <= extendNum * 2 + 1; i++) {            if (i < extendNum) {                waves[centerOne - extendNum + i] = lineWidth + (i + 1) * intervalH;                waves[centerTwo - extendNum + i] = waves[centerOne - extendNum + i];            } else if (i > extendNum) {                waves[centerOne - extendNum + i] = lineWidth + (extendNum * 2 - i + 1) * intervalH;                waves[centerTwo - extendNum + i] = waves[centerOne - extendNum + i];            } else {                waves[centerOne] = targetVolume;                waves[centerTwo] = waves[centerOne];            }        }        invalidate();        drawTime = System.currentTimeMillis();    }}